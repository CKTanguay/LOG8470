/* Constants */
#define N 4

/* Global variables */
byte I;
byte flag[N];
byte counter;
byte counter2;

proctype mutualExclusion(byte index) {
	flag[index] = 1;
	
	/* LIGNE 3*/
	counter = 0;
	do
	:: counter < N ->
		if
		:: flag[counter] >= 3 ->
			counter = 0;
		:: flag[counter] < 3 ->
			counter++;
		fi;
	:: counter >= N ->
		break
	od;

	/*LIGNE 4*/
	flag[index] = 3;
	
	counter = 0;
	/* LIGNE 5 */
	do
	:: counter < N ->
		if
		:: flag[counter] == 1 ->
			/* LIGNE 6 */
			flag[index] = 2;
			counter2 = 0;
			/* LIGNE 7*/
			do
			:: counter2 < N ->
				if
				:: flag[counter2] == 4 -> break
				fi;
				counter2++;
			:: counter2 >= N ->
				counter2 = 0;
			od;
		fi;
	:: counter >= N ->
		break
	od;
	
	/* LIGNE 8 */
	flag[index] = 4;
	
	/* LIGNE 9 */
	counter = 0;
	do
	:: counter < N ->
		if
		:: flag[counter] >= 2 ->
			counter = 0;
		:: flag[counter] < 2 ->
			counter++;
		fi;
	:: counter >= N ->
		break
	od;
	
	/* LIGNE 10-11 SECTION CRITIQUE */
	counter = 0;
	do
	:: counter < N ->
		if
		:: flag[counter + 1] == 0 || flag[counter + 1] == 1 || flag[counter + 1] == 4 ->
			counter++;
		:: flag[counter + 1] == 2 || flag[counter +1] == 3 ->
			counter = 0;
		fi;
	:: counter >= N ->
		break
	od;
	
	/* LIGNE 12 */
	flag[index] = 0;
}


init {
	byte proc;
	byte i;
	byte Ini[4];	/* N<=4 randomize the process numbers */
	atomic {

		I = 0;	/* pick a number to be assigned 1..N */
		do
		:: I < N ->
			if	/* non-deterministic choice */
			:: Ini[0] == 0 && N >= 1 -> Ini[0] = I
			:: Ini[1] == 0 && N >= 2 -> Ini[1] = I
			:: Ini[2] == 0 && N >= 3 -> Ini[2] = I
			:: Ini[3] == 0 && N >= 4 -> Ini[3] = I
			fi;
			I++
		:: I >= N ->	/* assigned all numbers 1..N */
			break
		od;

		proc = 1;
		i = 0;
		do
		:: proc <= N ->
			run mutualExclusion(Ini[i]);
			proc++;
			i++;
		:: proc > N -> break
		od
	}
}
